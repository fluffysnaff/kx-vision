"""
ARCHIVED - C++ Header Generator for GW2 API Item Data
Part of the kx-vision project: https://github.com/kxtools/kx-vision

This script is an archive of the logic needed to generate C++ headers
for the GW2 API /items endpoint. It is not used in the current build
process but is kept for future reference.
"""

import json
import time
import os
import logging
import re

# Setup simple logging
logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s')
logger = logging.getLogger(__name__)

# --- Configuration for ITEMS only ---
CACHE_FILE_PATH = "api_cache/ITEM_data.json"
OUTPUT_DIR = "../src/Game/Generated"

def sanitize_cpp_string(value):
    # (Same sanitize function as the other script)
    if not isinstance(value, str): value = str(value)
    value = value.replace("\\", "\\\\").replace('"', '\\"').replace('\n', '\\n').replace('\r', '\\r').replace('\t', '\\t')
    value = re.sub(r'[\x00-\x08\x0B\x0C\x0E-\x1F\x7F-\x9F]', '', value)
    return value

def sanitize_cpp_identifier(value):
    # (Same sanitize function as the other script)
    if not isinstance(value, str): value = str(value)
    value = re.sub(r'[^a-zA-Z0-9_]', '_', value)
    if value and value[0].isdigit(): value = f"_{value}"
    if not value: value = "Unknown"
    return value

def get_file_header():
    return f"""// This file is automatically generated by _archive_generate_item_headers.py. DO NOT EDIT.
// Generated on: {time.ctime()}
"""

def generate_item_files(item_data):
    """Generates C++ files for Item data."""
    logger.info("Generating C++ header files for Item data...")
    os.makedirs(OUTPUT_DIR, exist_ok=True)

    # Extract enum values for items
    all_rarities = sorted(list(set(sanitize_cpp_identifier(item.get('rarity', 'Unknown')) for item in item_data if item.get('rarity')))) or ['Unknown']
    all_item_types = sorted(list(set(sanitize_cpp_identifier(item.get('type', 'Unknown')) for item in item_data if item.get('type')))) or ['Unknown']
    
    # NOTE: This would need to be merged with EnumsAndStructs.h from the stat generator.
    # For simplicity, this example just prints them. A real implementation would require
    # a more complex script that combines enums from both sources.
    logger.info(f"Required Rarity Enums: {', '.join(all_rarities)}")
    logger.info(f"Required ItemType Enums: {', '.join(all_item_types)}")

    # Generate ItemData.h
    items_path = os.path.join(OUTPUT_DIR, "ItemData.h")
    with open(items_path, "w", encoding="utf-8") as f:
        logger.info(f"Generating {items_path}")
        f.write(get_file_header() + "\n\n")
        f.write("#ifndef KX_ITEM_DATA_H\n#define KX_ITEM_DATA_H\n\n")
        f.write('#include "EnumsAndStructs.h" // Assumes this file exists and has the required enums\n')
        f.write('#include <unordered_map>\n\n')
        f.write("namespace kx::data::item {\n\n")
        f.write("    // This would need a struct ItemData defined in EnumsAndStructs.h\n")
        f.write("    // struct ItemData { const char* name; ApiRarity rarity; ApiItemType type; };\n\n")
        f.write("    inline const std::unordered_map<uint32_t, ItemData> DATA = {\n")
        
        item_count = 0
        for item in item_data:
            if not (item.get('id') and item.get('name')):
                continue
            
            name = sanitize_cpp_string(item.get("name", ""))
            rarity = sanitize_cpp_identifier(item.get('rarity', 'Unknown'))
            item_type = sanitize_cpp_identifier(item.get('type', 'Unknown'))
            
            f.write(f'        {{ {item["id"]}, {{"{name}", kx::data::ApiRarity::{rarity}, kx::data::ApiItemType::{item_type}}} }},\n')
            item_count += 1
        
        f.write("    };\n\n} // namespace kx::data::item\n\n#endif // KX_ITEM_DATA_H\n")
        logger.info(f"Generated {item_count} item entries")

if __name__ == "__main__":
    logger.info("ARCHIVED SCRIPT: C++ item header generator...")
    try:
        with open(CACHE_FILE_PATH, "r", encoding="utf-8") as f:
            item_data = json.load(f)
        generate_item_files(item_data)
    except FileNotFoundError:
        logger.error(f"Cache file not found: {CACHE_FILE_PATH}")
        logger.error("Please run 'fetch_api_data.py' and ensure the ITEM endpoint is enabled.")
    except Exception as e:
        logger.error(f"An error occurred: {e}")