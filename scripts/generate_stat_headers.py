"""
C++ Header Generator for GW2 API Stat Data
Part of the kx-vision project: https://github.com/kxtools/kx-vision

Generates C++ header files from cached GW2 API stat data.
"""

import json
import time
import os
import logging
import re

# Setup simple logging
logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s')
logger = logging.getLogger(__name__)

# --- Configuration for STATS only ---
CACHE_FILE_PATH = "api_cache/STAT_data.json"
OUTPUT_DIR = "../src/Game/Generated"

def sanitize_cpp_string(value):
    """Properly sanitize strings for C++ code generation."""
    if not isinstance(value, str):
        value = str(value)
    value = value.replace("\\", "\\\\").replace('"', '\\"').replace('\n', '\\n').replace('\r', '\\r').replace('\t', '\\t')
    value = re.sub(r'[\x00-\x08\x0B\x0C\x0E-\x1F\x7F-\x9F]', '', value)
    return value

def sanitize_cpp_identifier(value):
    """Create valid C++ identifier from string."""
    if not isinstance(value, str):
        value = str(value)
    value = re.sub(r'[^a-zA-Z0-9_]', '_', value)
    if value and value[0].isdigit():
        value = f"_{value}"
    if not value:
        value = "Unknown"
    return value

def get_file_header():
    """Generate consistent file header."""
    return f"""// This file is automatically generated by generate_stat_headers.py. DO NOT EDIT.
// Generated on: {time.ctime()}
//
// Licensed under the same terms as the kx-vision project:
// https://github.com/kxtools/kx-vision
//
// MIT License
"""

def generate_cpp_files(stat_data):
    """Generate C++ header files from fetched stat data."""
    logger.info("Generating C++ header files for Stat data...")
    os.makedirs(OUTPUT_DIR, exist_ok=True)

    # Extract enum values for ApiAttribute from stat data
    all_attributes = sorted(list(set(
        sanitize_cpp_identifier(attr.get('attribute', 'Unknown')) 
        for stat in stat_data 
        for attr in stat.get('attributes', []) 
        if attr.get('attribute')
    ))) or ['Unknown']

    # Generate EnumsAndStructs.h (Simplified for stats only)
    enums_path = os.path.join(OUTPUT_DIR, "EnumsAndStructs.h")
    with open(enums_path, "w", encoding="utf-8") as f:
        logger.info("Generating EnumsAndStructs.h")
        f.write(get_file_header() + "\n\n")
        f.write("#ifndef KX_API_ENUMS_STRUCTS_H\n#define KX_API_ENUMS_STRUCTS_H\n\n")
        f.write("#include <cstdint>\n#include <vector>\n\n")
        f.write("namespace kx::data {\n\n")
        f.write(f"    enum class ApiAttribute {{ {', '.join(all_attributes)} }};\n\n")
        f.write("    struct StatAttribute { ApiAttribute attribute; };\n")
        f.write("    struct StatData { const char* name; std::vector<StatAttribute> attributes; };\n\n")
        f.write("} // namespace kx::data\n\n#endif // KX_API_ENUMS_STRUCTS_H\n")

    # Generate StatData.h
    stats_path = os.path.join(OUTPUT_DIR, "StatData.h")
    with open(stats_path, "w", encoding="utf-8") as f:
        logger.info("Generating StatData.h")
        f.write(get_file_header() + "\n\n")
        f.write("#ifndef KX_STAT_DATA_H\n#define KX_STAT_DATA_H\n\n")
        f.write('#include "EnumsAndStructs.h"\n#include <unordered_map>\n\n')
        f.write("namespace kx::data::stat {\n\n")
        f.write("    inline const std::unordered_map<uint32_t, StatData> DATA = {\n")
        
        stat_count = 0
        for stat in stat_data:
            if not (stat.get('id') and stat.get('name')):
                continue
            
            name = sanitize_cpp_string(stat.get("name", ""))
            f.write(f'        {{ {stat["id"]}, {{"{name}", {{')
            
            attributes = [
                f"{{kx::data::ApiAttribute::{sanitize_cpp_identifier(attr.get('attribute'))}}}"
                for attr in stat.get("attributes", []) if attr.get("attribute")
            ]
            
            f.write(", ".join(attributes))
            f.write("}} },\n")
            stat_count += 1
        
        f.write("    };\n\n} // namespace kx::data::stat\n\n#endif // KX_STAT_DATA_H\n")
        logger.info(f"Generated {stat_count} stat entries")

    # Generate main include file
    main_path = os.path.join(OUTPUT_DIR, "APIData.h")
    with open(main_path, "w", encoding="utf-8") as f:
        logger.info("Generating APIData.h")
        f.write(get_file_header() + "\n\n")
        f.write("#ifndef KX_API_DATA_H\n#define KX_API_DATA_H\n\n")
        f.write("// This is a convenience header to include all generated API data files.\n\n")
        f.write('#include "EnumsAndStructs.h"\n')
        f.write('#include "StatData.h"\n')
        f.write("\n#endif // KX_API_DATA_H\n")

    return True

if __name__ == "__main__":
    logger.info("Starting C++ stat header generator...")
    
    try:
        logger.info(f"Loading cached data from: {CACHE_FILE_PATH}")
        with open(CACHE_FILE_PATH, "r", encoding="utf-8") as f:
            stat_data = json.load(f)
        logger.info(f"Successfully loaded {len(stat_data)} entries")
        
        if generate_cpp_files(stat_data):
            logger.info("Script completed successfully!")
        else:
            logger.error("Script failed during file generation")
            exit(1)
            
    except FileNotFoundError:
        logger.error(f"Cache file not found: {CACHE_FILE_PATH}")
        logger.error("Please run 'fetch_api_data.py' first to generate STAT_data.json")
        exit(1)
    except (json.JSONDecodeError, IOError) as e:
        logger.error(f"Failed to load or parse {CACHE_FILE_PATH}: {e}")
        exit(1)
    except Exception as e:
        logger.error(f"An unexpected error occurred: {e}")
        exit(1)